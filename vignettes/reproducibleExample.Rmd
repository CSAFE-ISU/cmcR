---
title: "Cartridge Case Reproducible Example"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{cmcR Reproducible Example}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This vignette is meant to illustrate the usage of the cmcR package via a use-case similar to what a forensic examiner taking a cartridge case identification profiency test would experience. In particular, it is common in such tests to give an examiner some number of "known match" cartridge cases and asked to identify additional matches in a collection of unknown-source cartridge cases.

To install the cmcR package from github, run the following command in your R console.

```{r eval=FALSE}
devtools::install_github("https://github.com/jzemmels/cmcR")
```


```{r setup, message=FALSE,warning=FALSE}
library(cmcR)
library(magrittr)
library(ggplot2)
library(dplyr)
```

For this use case, suppose we have two known match cartridge cases (km1 and km2) and two of unknown source (unknown1 and unknown2). Let's pretend that we don't see the file path clearing indicating which of the unknown source cartridge cases match the known source.

```{r}
km1_raw <- x3ptools::read_x3p("~/bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul 1-1.x3p")
km2_raw <- x3ptools::read_x3p("~/bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul 1-2.x3p")
unknown1_raw <- x3ptools::read_x3p("~/bulletCartridgeScans/fadul_allScans/Fadul_2/cc/Fadul 2-1.x3p")
unknown2_raw <- x3ptools::read_x3p("~/bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul F.x3p")
```

## Cartridge Case Visualization {.tabset .tabset-pills}

There are a number of ways to visualize a cartridge case scans, each with their own pros/cons.

### Imager w/ Base Plot
A quick yet inflexible way is to turn the surface matrix into a `cimg` object and use base plot.

```{r}
par(mar = c(1,1,1,1))

imager::imlist(
km1_raw$surface.matrix %>%
  imager::as.cimg(),
km2_raw$surface.matrix %>%
  imager::as.cimg(),
unknown1_raw$surface.matrix %>%
  imager::as.cimg(),
unknown2_raw$surface.matrix %>%
  imager::as.cimg()
) %>%
  plot()
```

### ggplot2

ggplots are more flexible, but geom_tile takes a considerable amount of time to plot relative to base plotting a cimg object.

```{r}
km1_raw$surface.matrix %>%
  imager::as.cimg() %>%
  as.data.frame() %>%
  ggplot(aes(x = x,y = y)) +
  geom_raster(aes(fill = value)) +
  scale_fill_gradient2(low = "grey0",
                       mid = "grey50",
                       high = "grey100",
                       na.value = "white",
                       midpoint = median(as.vector(median(km1_raw$surface.matrix,
                                                          na.rm = TRUE)))) +
  coord_fixed(expand = FALSE) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.title.y = element_blank())
```

### x3ptools::image_x3p

The `x3ptools::image_x3p` function provides 3D visualization functionality, but requires opening an RGL device on an individual machine (can't be viewed in an R Markdown file without making it huge)

```{r eval=FALSE}
km1_raw %>%
  x3ptools::image_x3p(zoom = .7)
```


## Pre-processing

If we want to compare these cartridge case scans based on their breech face impressions, they need to undergo some pre-processing. The `cmcR` package has the modularized family of `preProcess_` functions or the all-in-one (except Gaussian filtering) `selectBFImpression_` functions to accomplish this.

Below we can see how the `preProcess_` family of functions can be used to process a cartridge case scan. The RANSAC method is applied twice for a more precise estimate of the breech face impression height value. Then the whitespace (all NA-valued rows/columns) on the exterior of the breech face impression is cropped. Next the firing pin circle is automatically estimated and any pixels within this circle are filtered out the scan. Lastly, a lowpass Gaussian filter meant to reduce the effect of high frequency "noise" in the scan is applied.

```{r}
set.seed(3152020) #RANSAC method is based on randomly sampling points in matrix

km1_residuals <- km1_raw %>%
  x3ptools::sample_x3p(m = 2) #down-sampled copy of km1_raw

km1_residuals$surface.matrix <- km1_residuals$surface.matrix %>%
  preProcess_ransac(inlierTreshold = 10^(-5),
                    finalSelectionThreshold = 2*(10^(-5)),
                    iters = 150) %>%
  preProcess_levelBF(useResiduals = TRUE) %>%
  preProcess_ransac(inlierTreshold = .1*(10^(-5)),
                    finalSelectionThreshold = 2*(10^(-5)),
                    iters = 300) %>%
  preProcess_levelBF(useResiduals = TRUE) %>%
  preProcess_cropWS(croppingThresh = 2) %>%
  preProcess_removeFPCircle(aggregation_function = mean,
                            smootherSize = 2*round((.1*nrow(.)/2)) + 1,
                            meshSize = 1,
                            houghScoreQuant = .9) %>%
  preProcess_gaussFilter(res = km1_residuals$header.info$incrementY,
                         wavelength = 16,
                         filtertype = "lp")
```

```{r eval=FALSE}
km1_residuals %>%
  x3ptools::image_x3p(zoom = .7)
```

The `selectBFImpression_` functions perform all of the pre-processing steps except for the Gaussian filtering in one function call. The following will process the 3 other scans in an equivalent manner to km1_residuals above. Note that the `selectBFImpression_` functions actually returns a list of two elements: `params` containing the list of parameters under which the function call was made (for reproducibility purposes) and `x3p` containing the actual processed x3p object.

```{r}
km2_residuals <- selectBFImpression_sample_x3p(x3p_path = "../../bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul 1-2.x3p",
                                               ransacIters = 150,
                                               ransacInlierThresh = 10^-5,
                                               ransacFinalSelectThresh = 2*(10^-5),
                                               useResiduals = TRUE)
unknown1_residuals <- selectBFImpression_sample_x3p(x3p_path = "../../bulletCartridgeScans/fadul_allScans/Fadul_2/cc/Fadul 2-1.x3p",
                                                    ransacIters = 150,
                                                    ransacInlierThresh = 10^-5,
                                                    ransacFinalSelectThresh = 2*(10^-5),
                                                    useResiduals = TRUE)
unknown2_residuals <- selectBFImpression_sample_x3p(x3p_path = "../../bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul F.x3p",
                                                    ransacIters = 150,
                                                    ransacInlierThresh = 10^-5,
                                                    ransacFinalSelectThresh = 2*(10^-5),
                                                    useResiduals = TRUE)

km2_residuals$x3p$surface.matrix <- 
  cmcR::preProcess_gaussFilter(surfaceMat = km2_residuals$x3p$surface.matrix,
                               res = km2_residuals$x3p$header.info$incrementY,
                               wavelength = 16,
                               filtertype = "lp")

unknown1_residuals$x3p$surface.matrix <- 
  cmcR::preProcess_gaussFilter(surfaceMat = unknown1_residuals$x3p$surface.matrix,
                               res = unknown1_residuals$x3p$header.info$incrementY,
                               wavelength = 16,
                               filtertype = "lp")

unknown2_residuals$x3p$surface.matrix <- 
  cmcR::preProcess_gaussFilter(surfaceMat = unknown2_residuals$x3p$surface.matrix,
                               res = unknown2_residuals$x3p$header.info$incrementY,
                               wavelength = 16,
                               filtertype = "lp")
```

```{r}
par(mar = c(1,1,1,1))

imager::imlist(
km1_residuals$surface.matrix %>%
  imager::as.cimg(),
km2_residuals$x3p$surface.matrix %>%
  imager::as.cimg(),
unknown1_residuals$x3p$surface.matrix %>%
  imager::as.cimg(),
unknown2_residuals$x3p$surface.matrix %>%
  imager::as.cimg()
) %>%
  plot()
```

## Congruent Matching Cells CCF calculation

The Congruent Matching Cells (CMC) method was developed at the National Institute of Standards and Technology (NIST) to quantify the similarity between two spent cartridge cases based on their breech face impressions (Song (2013)). The CMC method involves dividing a breechface impression scan into a grid of cells and comparing each cell in one scan to a corresponding region in the other scan.  The motivation for this particular methodis that two breech face impressions tend to have regions of high similarity, e.g., where the firearmâ€™s breech face impressed strongly into the cartridge case, and regions of low similarity, e.g., where the breech face may not have come into contact with the cartridge case.  The highly similar regions may be drowned-out, in a sense, by the less similar regions if one were to calculate a similarity score considering the entirety of the two scans.  By breaking up the breech face scans into a grid of cells, one can instead use the number of highly similar cells between the two scans as a more granular similarity metric.

The `cellCCF` and `cellCCF_bothDirections` functions perform the splitting of two surface matrices into a grid of cells and performing the cross-correlation calculation for a variety of rotation values. The only difference between the two functions is that `cellCCF_bothDirections` calls `cellCCF` twice where each scan in a pair plays the role of the "questioned" scan that is divided into cells. These functions simply return results of the comparison and don't actually implement any of the CMC logic that goes into identifying "congruent matching cells."

The call below will compare `km1_residuals` and `unknown1_residuals` by performing the following:

1) Divide one of the matrices into a grid of $8 \times 8$ cells
2) Determine which of these cells contains fewer than 15% of observed values (i.e., 85% or more NA values). These cells are not considered for the CCF calculation.
3) For each remaining cell:
    (a) rotate the other matrix (not the one divided into cells) by some theta value using a linear interpolation scheme
    (b) extract a region from this rotated matrix that is centered on the same index as the cell is in its matrix but is 4 times larger.
    (c) shift each cell/region by its respective average element value and divide by its standard deviation
    (d) calculate the translation, $(dx,dy)$, values by which the maximum CCF is attained between a cell/region pair
    (e) using these translation values, calculate the "raw" cross-correlation between the cell and the cell-sized portion of the larger region at which the max CCF was attained
4) Compile a list of data frames, one per rotation value, of CCF, dx, and dy values per cell/region pair
5) Perform steps 1-4 again, but by dividing the other matrix into a grid of cells to be compared to larger regions in the other matrix (i.e., the matrices swap roles).
 
For now we'll just compare km1 to the two unknown source cartridge cases. The comparisons of km2 will be discussed below.

```{r}
km1_unknown1_comparison <- cellCCF_bothDirections(km1_residuals,
                                                  unknown1_residuals$x3p,
                                                  thetas = seq(-30,30,by = 3),
                                                  cellNumHoriz = 8,
                                                  cellNumVert = 8,
                                                  regionToCellProp = 4,
                                                  minObservedProp = .15,
                                                  centerCell = "individualCell",
                                                  scaleCell = "individualCell")

km1_unknown2_comparison <- cellCCF_bothDirections(km1_residuals,
                                                  unknown2_residuals$x3p,
                                                  thetas = seq(-30,30,by = 3),
                                                  cellNumHoriz = 8,
                                                  cellNumVert = 8,
                                                  regionToCellProp = 4,
                                                  minObservedProp = .15,
                                                  centerCell = "individualCell",
                                                  scaleCell = "individualCell")
```

We can see the first 6 rows of one of these data frames, specifically where unknown1_residuals was rotated by 15 degrees before being compared to the cells of km1_residuals. The `cellID` column corresponds to the locations of each cell in km1_residuals. The `cellNum` column indexes the cells starting in the top left corner of the matrix moving right. The fact that this `cellNum == 1` is missing from this data frame means that the top left corner of the matrix contains too few observed (less than 15%) observed values to be considered for the CCF calculation. The `ccf`, `dx`, and `dy` columns represent the CCF$_{\max}$ value for a particular cell/region pair as well as the associated translation values at which this CCF value occurred. The values in the `ccf` column were calculated by replacing missing values (of which there are often many) with the average value in the cells/regions (which is necessary for calculating the CCF using the Cross-Correlation Theorem). The `rawCorr` column, on the other hand, contains correlation values calculated by effectively ignoring any NA-valued elements (specifically, using the `cor` function with `use = "pairwise.complete.obs"`).

```{r}
km1_unknown1_comparison$comparison_1to2$ccfResults$`21` %>%
  DT::datatable(options = list(pageLength = 5))
```

We are interested in extracting features from these CCF comparison results to differentiate matches from non-matches. In particular, we are interested only in cell/region pairs that are above a certain correlation threshold and have `dx`, `dy`, and `theta` values that are "close" to consensus-based values.

```{r}
km1_unknown1_comparison$comparison_1to2$ccfResults %>%
  topResultsPerCell() %>%
  DT::datatable(options = list(pageLength = 5))
```

```{r}
km1_unknown1_comparison$comparison_1to2$ccfResults %>%
  topResultsPerCell() %>%
  cmcFilter(corr_thresh = .8,
            dx_thresh = 15) %>%
  DT::datatable()
```

```{r}
km1_unknown2_comparison$comparison_1to2$ccfResults %>%
  topResultsPerCell() %>%
  cmcFilter(corr_thresh = .8,
            dx_thresh = 15) %>%
  DT::datatable(options = list(pageLength = 5))
```


Having chosen correlation and translation thresholds by which we can classify cell pairs as "congruent matching cells," a useful way to determine an estimate for the rotation values by which two cartridge cases will align is to plot the number of CMCs per rotation value. The plots below show the "forward" and "backward" distribution of CMCs per theta value for the comparisons between km1 and unknown1 as well as km1 and unknown2. We can clearly see that there are very few 

```{r}
bind_rows(
  km1_unknown1_comparison$comparison_1to2$ccfResults %>%
    cmcR:::cmcFilterPerTheta(consensus_function = median,
                             corr_thresh = .8,
                             dx_thresh = 15,
                             dy_thresh = 15,
                             theta_thresh = 3) %>%
    mutate(comparison = "A vs. B"),
  km1_unknown1_comparison$comparison_2to1$ccfResults %>%
    cmcR:::cmcFilterPerTheta(consensus_function = median,
                             corr_thresh = .8,
                             dx_thresh = 15,
                             dy_thresh = 15,
                             theta_thresh = 3) %>%
    mutate(comparison = "B vs. A")
) %>%
  group_by(comparison,theta) %>%
  tally() %>%
  mutate(cmcHigh = max(n) - 1)  %>%
  ggplot(aes(x = theta,y = n)) +
  geom_bar(stat = "identity") +
  theme_bw()  +
  xlab(expression(theta*" (degree)")) +
  ylab("CMC number") +
  facet_wrap(~ comparison,ncol = 1)  +
  ylim(c(NA,25)) +
  geom_hline(aes(yintercept = cmcHigh),
                      colour = "black",
                      linetype = "dashed") +
  geom_text(aes(x = min(theta) + 3,
                                  y = cmcHigh,
                                  label = paste0("High CMC = ",cmcHigh)),
                     nudge_y = 1,
                     fontface = "plain",
                     family = "sans")
```

The same plot for the comparison betwen km1 and unknown2 is shown below.

```{r echo=FALSE}
bind_rows(
  km1_unknown2_comparison$comparison_1to2$ccfResults %>%
    cmcR:::cmcFilterPerTheta(consensus_function = median,
                             corr_thresh = .8,
                             dx_thresh = 15,
                             dy_thresh = 15,
                             theta_thresh = 3) %>%
    mutate(comparison = "A vs. B"),
  km1_unknown2_comparison$comparison_2to1$ccfResults %>%
    cmcR:::cmcFilterPerTheta(consensus_function = median,
                             corr_thresh = .8,
                             dx_thresh = 15,
                             dy_thresh = 15,
                             theta_thresh = 3) %>%
    mutate(comparison = "B vs. A")
) %>%
  group_by(comparison,theta) %>%
  tally() %>%
  mutate(cmcHigh = max(n) - 1) %>%
  ggplot(aes(x = theta,y = n)) +
  geom_bar(stat = "identity") +
  theme_bw() +
  xlab(expression(theta*" (degree)")) +
  ylab("CMC number") +
  facet_wrap(~ comparison,ncol = 1) +
  ylim(c(NA,25))  +
  geom_hline(aes(yintercept = cmcHigh),
                      colour = "black",
                      linetype = "dashed") +
  geom_text(aes(x = min(theta) + 3,
                                  y = cmcHigh,
                                  label = paste0("High CMC = ",cmcHigh)),
                     nudge_y = 1,
                     fontface = "plain",
                     family = "sans")
```


```{r}
km1_unknown1_cmcs <- cmcR::cmcFilter_improved(km1_unknown1_comparison,
                                              consensus_function = median,
                                              corr_thresh = .8,
                                              dx_thresh = 15)

km1_unknown2_cmcs <- cmcR::cmcFilter_improved(km1_unknown2_comparison,
                                              consensus_function = median,
                                              corr_thresh = .8,
                                              dx_thresh = 15)
```

```{r}
km1_unknown1_cmcs$initialCMCs
```

```{r}
km1_unknown2_cmcs$finalCMCs %>%
  DT::datatable(options = list(pageLength = 5))
```


```{r}
km2_unknown1_comparison <- cellCCF_bothDirections(km2_residuals$x3p,
                                                  unknown1_residuals$x3p,
                                                  thetas = seq(-30,30,by = 3),
                                                  cellNumHoriz = 8,
                                                  regionToCellProp = 4,
                                                  minObservedProp = .15,
                                                  centerCell = "individualCell",
                                                  scaleCell = "individualCell")

km2_unknown2_comparison <- cellCCF_bothDirections(km2_residuals$x3p,
                                                  unknown2_residuals$x3p,
                                                  thetas = seq(-30,30,by = 3),
                                                  cellNumHoriz = 8,
                                                  regionToCellProp = 4,
                                                  minObservedProp = .15,
                                                  centerCell = "individualCell",
                                                  scaleCell = "individualCell")

km2_unknown1_cmcs <- cmcR::cmcFilter_improved(km2_unknown1_comparison,
                                              consensus_function = median,
                                              corr_thresh = .8,
                                              dx_thresh = 15)

km2_unknown2_cmcs <- cmcR::cmcFilter_improved(km2_unknown2_comparison,
                                              consensus_function = median,
                                              corr_thresh = .8,
                                              dx_thresh = 15)
```

```{r}
km2_unknown2_cmcs$finalCMCs %>%
  DT::datatable(options = list(pageLength = 5))
```


```{r}
cmcR::cmcPlot(unknown1_residuals$x3p,
              cmcDF = km1_unknown1_cmcs$initialCMCs[[1]][[2]])
```



```{r}
cmcR::cmcPlot(unknown2_residuals$x3p,
              cmcDF = km1_unknown2_cmcs$initialCMCs[[1]][[2]])
```

```{r eval=FALSE}
cmcR::cmcPlot(unknown1_residuals$x3p,
              cmcDF = km2_unknown1_cmcs$initialCMCs[[1]][[1]])
```

```{r}
cmcR::cmcPlot(unknown1_residuals$x3p,
              cmcDF = km2_unknown2_cmcs$initialCMCs[[1]][[2]])
```

```{r}
cmcR::cmcPlot(unknown2_residuals$x3p,
              cmcDF = km2_unknown2_cmcs$finalCMCs)
```

## References
